# 实验2：汇编语言及程序设计
## 背景知识
### 1.汇编语言
<p>汇编语言是计算机，微处理器，微控制器和其他可编程器件的低级编程语言。 它实现了对给定CPU架构进行编程所需的机器代码和其他常量的符号表示。 该表示通常由硬件制造商定义，并且基于符号化处理步骤（指令），处理器寄存器，存储器位置和其他语言特征的助记符。 因此，汇编语言对于某些物理（或虚拟）计算机体系结构是特定的。 这意味着每个计算机体系结构和处理器架构通常都有自己的机器语言。</p>
<p>一个称为汇编器的实用程序用于将汇编语言语句转换为目标计算机的机器代码。 汇编程序从助记符语句到机器指令和数据执行或多或少的同构翻译（一对一映射）。 这与高级语言相反，其中单个语句通常导致许多机器指令。</p>

### 2.关键概念
#### 汇编器
<p>通常，现代<b>汇编器</b>通过将汇编指令助记符转换为操作码，并通过解析内存位置和其他实体的符号名称来创建目标代码。 使用符号参考是汇编器的一个关键特性，节省了修改后的繁琐计算和手动地址更新。 大多数汇编器还包括用于执行文本替换的宏设施，例如，生成通用短序列指令，而不是称为子程序。</p>

#### 通行数
<p>基于需要多少通过源来生成可执行程序，有两种类型的汇编程序。</p>

- 一次汇编程序通过源代码一次，并假设所有符号将在引用它们的任何指令之前定义。
- 双遍汇编器在第一遍中创建具有所有符号及其值的表，然后在第二遍中使用表来生成代码。 汇编器必须至少能够确定第一遍的每个指令的长度，以便可以计算符号的地址。

<p>单程汇编器的优点是速度快，这与计算机速度和能力的进步一样重要。 两路汇编器的优点在于可以在程序源代码的任何地方定义符号。 这样可以以更合乎逻辑和有意义的方式定义程序，从而使两通汇编程序更易于阅读和维护。</p>

#### 汇编语言程序
<p>用汇编语言编写的程序由一系列助记符语句和元语句（已知各种指令，伪指令和伪操作），注释和数据组成。 这些由汇编程序转换成可以加载到内存中并执行的可执行指令流。 汇编器还可以用于生成数据块，从格式化和注释的源代码中被其他代码使用。</p>

### 3.语言设计
#### 基本要素
<p>组装者的作者将语句和他们使用的命名法分类的方式有很大的差异。 特别地，有些描述除机器助记符或扩展助记以外的任何东西作为伪操作（伪操作）。 典型的汇编语言由用于定义程序操作的3种指令语句组成：</p>

- 操作码助记符
- 数据部分
- 汇编指令

#### 操作码助记符和扩展助记符
<p>汇编语言中的说明（语句）通常非常简单，与高级语言不同。 通常，助记符是单个可执行机器语言指令（操作码）的符号名称，并且为每个机器语言指令定义了至少一个操作码助记符。 每个指令通常由*操作*或*操作码*加上零个或多个*操作数*组成。 大多数指令是指单个值或一对值。 操作数可以是立即的（通常是指令本身编码的一个字节值），指令中指定的寄存器，隐含的数据或位于存储器其他位置的数据地址。 这由底层处理器架构决定：汇编器仅仅反映了这种架构的工作原理。 *扩展助记符*通常用于指定操作码与特定操作数的组合。</p>
<p>*扩展助记符*通常用于支持指令的专门用途，通常用于指令名称不明显的目的。 例如，许多 CPU 没有明确的 NOP 指令，但确实有可以用于此目的的指令。 在 8086 CPU 中，指令 *xchg ax,ax* 用于 *nop* ，*nop* 是用于对指令 *xchg ax,ax* 进行编码的伪操作码。</p>
<p>一些汇编器还支持生成两个或多个机器指令的简单内置宏指令。 例如，对于一些 Z80 汇编器，指令 *ld hl,bc* 被识别生成 *ld l,c* ，后跟 *ld h,b* 。 这些有时被称为*伪操作码*。</p> 

#### 数据部分
<p>有用于定义数据元素以保存数据和变量的指令。 它们定义了类型数据，数据的长度和对齐方式。 这些指令还可以定义数据是否可用于外部程序（单独组合的程序）或仅限于定义数据段的程序。 一些汇编器将它们分类为伪操作。</p>

#### 汇编指令
<p>汇编指令（也称为伪操作码，伪操作或伪操作）是汇编程序在汇编时执行的指令，而不是由运行时的 CPU 执行的指令。 它们可以使程序的组合依赖于程序员输入的参数，从而可以为不同的应用程序组合一个程序。 它们也可用于操纵程序的呈现，使其更易于阅读和维护。 例如，指令将用于预留存储区域和可选的其初始内容。 指令的名称通常以一个点开始，以区别于机器指令。</p>
<p>符号汇编程序使程序员将任意名称（*标签*或*符号*）与内存位置相关联。 通常，每个常量和变量都有一个名称，所以指令可以通过名称引用这些位置，从而促进自我记录代码。 在可执行代码中，每个子例程的名称与其入口点相关联，因此对子例程的任何调用都可以使用其名称。 在内部子程序中，GOTO 目的地是标签。 一些汇编器支持与正常符号词汇不同的*局部符号*。</p>
<p>汇编语言与大多数其他计算机语言一样，允许注释成为汇编程序源忽略的汇编源代码。 由于汇编代码比较高级语言更好地使用注释，因为一系列指令的含义和目的难以从代码本身中解读出来。</p>

#### 宏
<p>许多汇编程序支持*预定义的宏*，而其他汇编程序支持*程序员定义*的（和重复定义的）宏，它们涉及嵌入变量和常量的文本行序列。 文本行的这一序列可以包括操作码或指令。 一旦定义了宏，它的名称就可以用来替代助记符。 当汇编程序处理这样的语句时，它会将该语句替换为与该宏相关联的文本行，然后将其处理为它们存在于源代码文件中（包括在某些汇编程序中扩展替换文本中存在的任何宏）。</p>
<p>由于宏可以具有“短”名称，而是扩展到几行或许多代码行，它们可用于使汇编语言程序看起来远远更短，与较高级别的语言一样，需要较少的源代码行。 它们还可用于向组装程序添加更高级别的结构，可选地通过参数和其他类似功能介绍嵌入式调试代码。</p>
<p>许多汇编器具有用于系统调用和其他特殊代码序列的内置（或*预定义*）宏，例如通过游戏，软件安全，数据管理和密码学中使用的高级逐位和布尔运算来实现数据的生成和存储。</p>
<p>（摘自 <http://en.wikipedia.org/wiki/Assembly_language>）</p>

## 实验目的

- 了解汇编语言(assembly language)与机器指令（指令集体系结构）之间的关系
- 掌握汇编程序(assembler)的基本内容和实现原理
- 掌握汇编语言程序设计

## 实验内容

1. 定义 NK-CPU 汇编语言的基本内容
2. 实现 NK-CPU 的汇编程序
3. 使用 NK-CPU 汇编语言编写对 20 个随机数的排序程序

## 要求
NK-CPU 的汇编程序需要使用 C 语言或 C++语言实现。 